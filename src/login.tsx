
import React, { useContext, useEffect, useState, MouseEvent } from 'react'
import { ApolloError } from 'apollo-client'
import { GraphQLError } from 'graphql'

import { useCredentials, UMApolloContext, UMAppIdContext } from './auth'
import { useCsrfMutation } from './hooks'
import { useForm, InputValueMap, InputLabel } from './forms'
import { ErrorMessage } from './errors'
import { UMRequestPasswordResetForm } from './passwords'

import {
  LOGIN_MUT,
  LOGOUT_MUT,
  CREATE_ACCOUNT_MUT,
  SESSION_QUERY
} from './fragments'

const getId = (prefix: string | undefined, suffix: string) => {
  if (prefix) {
    return `${prefix}-${suffix}`
  } else {
    // add some random goobledygook to avoid conflicts with other component
    // libraries.
    return `um3kfiekd-${suffix}`
  }
}

export const useLogout = () => {
  const client = useContext(UMApolloContext)
  const appId = useContext(UMAppIdContext)

  const [submit, ret] =
    useCsrfMutation(
      LOGOUT_MUT,
      {
        client,
        refetchQueries: [{ query: SESSION_QUERY, variables: { appId } }]
      }
    )

  const { loading, error, data } = ret

  const success = !loading && !error && data
  const retObj = { ...ret, success }
  return [submit, retObj] as [typeof submit, typeof retObj]
}

export const useLogin = () => {
  const client = useContext(UMApolloContext)
  const appId = useContext(UMAppIdContext)

  const [submitLogin, ret] =
    useCsrfMutation(
      LOGIN_MUT,
      {
        client,
        refetchQueries: [{ query: SESSION_QUERY, variables: { appId } }]
      }
    )

  const { loading, error, data } = ret

  const submit = (values: InputValueMap) => {
    submitLogin({ variables: values })
  }

  const success = !loading && !error && data
  const retObj = { ...ret, success }
  // typescript can't infer tuples :(
  return [submit, retObj] as [typeof submit, typeof retObj]
}

export const useCreateAccount = () => {
  const client = useContext(UMApolloContext)
  const appId = useContext(UMAppIdContext)
  const [submitCreateAccount, ret] =
    useCsrfMutation(
      CREATE_ACCOUNT_MUT,
      {
        client,
        refetchQueries: [{ query: SESSION_QUERY, variables: { appId } }]
      })

  const { loading, error, data } = ret

  const submit = (values: InputValueMap) => {
    submitCreateAccount({ variables: values })
  }

  const success = !loading && !error && data
  const retObj = { ...ret, success }
  // typescript can't infer tuples :(
  return [submit, retObj] as [typeof submit, typeof retObj]
}

type LoginFormProps = {
  onLogin?: () => void

  // If for some reason, you have conflicts with the IDs nodes generated by
  // UMLoginForm, you can add a id prefix.
  // This can also be useful if you need to embed more than one UMAccountCreationForm
  // in the same page.
  idPrefix?: string

  // Render labels before inputs in the form (default true)
  labelsFirst?: boolean
}

export const UMLoginForm: React.FC<LoginFormProps> = ({onLogin, idPrefix, labelsFirst}) => {

  if (labelsFirst == null) {
    labelsFirst = true
  }

  const [isForgotPasswordMode, setForgotPasswordMode] = useState(false)

  const [submit, { loading, error, called }] = useLogin()

  const { onSubmit, onChange, values } = useForm(submit)

  const { id: credentialId, loading: credentialLoading } = useCredentials()

  useEffect(() => {
    // We need to wait until the credential context is reporting that we are logged in,
    // (in addition to waiting for useLogin() mutation to finish). Otherwise there's a window
    // during which other components might think we aren't logged in, even though we are
    // about to be.
    if (called && !loading && !error && credentialId && !credentialLoading && onLogin) {
      onLogin()
    }
  })

  if (isForgotPasswordMode) {
    return <>
      <div className="p-2">
        Enter your email to get a password reset link.
      </div>
      <UMRequestPasswordResetForm labelsFirst={false}
        onCancel={() => { setForgotPasswordMode(false)}} />
    </>
  }

  return <form className="form-signin" onSubmit={onSubmit}>
    <div className="form-label-group mb-2">
      <InputLabel flip={labelsFirst}>
        <input type="email" data-var="email" className="form-control"
               value={values.email || ''} onChange={onChange}
               id={getId(idPrefix, "login-email")}
               placeholder="Email address" required autoFocus />
        <label htmlFor={getId(idPrefix, "login-email")}>Email address</label>
      </InputLabel>
    </div>

    <div className="form-label-group mb-2">
      <InputLabel flip={labelsFirst}>
        <input type="password" data-var="password" className="form-control"
               value={values.password || ''} onChange={onChange}
               id={getId(idPrefix, "login-password")}
               placeholder="Password" required />
        <label htmlFor={getId(idPrefix, "login-password")}>Password</label>
      </InputLabel>
    </div>

    <div className="custom-control custom-checkbox mb-2">
      <input type="checkbox" className="custom-control-input" data-var="stayLoggedIn"
             id={getId(idPrefix, "login-stay-logged-in")}
             onChange={onChange} checked={Boolean(values.stayLoggedIn)} />
      <label className="custom-control-label" htmlFor={getId(idPrefix, "login-stay-logged-in")}>
        Remember me
      </label>
    </div>

    <div className="mb-3 justify-content-between d-flex">
      <button className="btn btn-primary" type="submit">Sign in</button>
      <button className="btn btn-outline-primary" type="button"
              onClick={(e) => { e.preventDefault(); setForgotPasswordMode(true); }}>
        Forgot Password?
      </button>
    </div>
    <ErrorMessage error={error} />
  </form>
}

// User creation error messages are likely to occur in normal situations,
// so they get a bit more attention than ErrorMessage can give.
const UserCreateError: React.FC<{error?: ApolloError}> = ({error}) => {
  if (!error) { return null }

  const formatMsg = (e: GraphQLError) => {
    if (e.extensions == null) {
      return null
    }
    const { exception } = e.extensions
    if (exception) {
      switch (exception.code) {
        case 'EMAIL_EXISTS':
          return <>
            An account with the email address {e.extensions.email} already exists.
          </>
      }
    }

    return e.message
  }

  return <>
    {error.graphQLErrors.map((e, i) => (
      <div className="alert alert-danger" role="alert" key={i}>
        {formatMsg(e) || 'uknown error'}
      </div>
    ))}
  </>
}

type AccountCreationProps = {
  loginAfterCreation?: boolean
  onLogin?: () => void

  // If for some reason, you have conflicts with the IDs nodes generated by
  // UMAccountCreationForm, you can add a id prefix.
  // This can also be useful if you need to embed more than one UMAccountCreationForm
  // in the same page.
  idPrefix?: string

  // Render labels before inputs in the form (default true)
  labelsFirst?: boolean
}

export const UMAccountCreationForm: React.FC<AccountCreationProps> =
  ({loginAfterCreation, onLogin, idPrefix, labelsFirst}) => {

  if (labelsFirst == null) {
    labelsFirst = true
  }

  if (loginAfterCreation == null) {
    loginAfterCreation = true
  }

  const { id } = useCredentials()
  const [submit, { error, success }] = useCreateAccount()

  const { onSubmit, onChange, values } = useForm(submit,
    { loginAfterCreation }
  )

  useEffect(() => {
    if (success && id && onLogin) {
      onLogin()
    }
  })

  return <>
    <form className="form-signin" onSubmit={onSubmit}>
      <div className="form-label-group mb-2">
        <InputLabel flip={labelsFirst}>
          <input type="email" data-var="email" className="form-control"
                 id={getId(idPrefix, "account-creation-email")}
                 value={values.email || ''} onChange={onChange}
                 placeholder="Email address" required autoFocus />
          <label htmlFor={getId(idPrefix, "account-creation-email")}>Email address</label>
        </InputLabel>
      </div>

      <div className="form-label-group mb-2">
        <InputLabel flip={labelsFirst}>
          <input type="password" data-var="password" className="form-control"
                 id={getId(idPrefix, "account-creation-password")}
                 value={values.password || ''} onChange={onChange}
                 placeholder="Password" required />
          <label htmlFor={getId(idPrefix, "account-creation-password")}>Password</label>
        </InputLabel>
      </div>

      { loginAfterCreation &&
      <div className="custom-control custom-checkbox mb-2">
        <input type="checkbox" className="custom-control-input" data-var="stayLoggedIn"
               id={getId(idPrefix, "account-creation-stay-logged-in")}
               onChange={onChange} checked={Boolean(values.stayLoggedIn)} />
        <label className="custom-control-label" htmlFor={getId(idPrefix, "account-creation-stay-logged-in")}>
          Remember me
        </label>
      </div> }

      <div className="mb-3">
        <button className="btn btn-primary" type="submit">Create Account</button>
      </div>
    </form>
    <UserCreateError error={error} />
  </>
}

export const UMLogoutButton: React.FC<{}> = () => {

  const [submit, { error }] = useLogout()

  const onClick = (e: MouseEvent) => {
    e.preventDefault()
    submit()
  }

  return <>
    <button className="btn btn-outline-primary" type="button" onClick={onClick}>Logout</button>
    <ErrorMessage error={error} />
  </>
}
