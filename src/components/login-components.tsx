
import React, { ReactNode, useEffect, useState, MouseEvent } from 'react'
import { Formik, Form, Field, FormikValues, FormikErrors } from 'formik'
import { ApolloError } from 'apollo-client'
import { GraphQLError } from 'graphql'
import classNames from 'classnames'

import { Icon } from 'react-icons-kit'
import { google } from 'react-icons-kit/fa/google'
import { facebookOfficial } from 'react-icons-kit/fa/facebookOfficial'
import { github } from 'react-icons-kit/fa/github'

import { useToken, useAppConfig, useAppId } from '../auth'
import { useCsrfMutation } from '../hooks'
import { InputLabel, InputComponentType } from './form-util'
import { ErrorMessage } from '../errors'
import { useGetRecoveryCodeCount } from '../recoverycodes'
import { ReauthContext } from '../reauth'
import { PasswordScore, RequestPasswordResetForm } from './password-components'
import { MFAForm } from './totp-components'
import { useReauthToken } from '../reauth'

import { useClearTotpMutation } from '../../gen/operations'

type IconProps = {
  color?: string,
  size?: string | number
}

const GoogleLogo = (props: IconProps) => <Icon icon={google} {...props} />
const FbLogo = (props: IconProps) => <Icon icon={facebookOfficial} {...props} />
const GithubLogo = (props: IconProps) => <Icon icon={github} {...props} />

import {
  useCreateAccount,
  useOauthToken,
  useLogin,
  useLogout
} from '../login'

import {
  CreateAccountMutationVariables,
  LoginMutationVariables
} from '../../gen/operations'

const getId = (prefix: string | undefined, suffix: string) => {
  if (prefix) {
    return `${prefix}-${suffix}`
  } else {
    // add some random goobledygook to avoid conflicts with other component
    // libraries.
    return `um3kfiekd-${suffix}`
  }
}

type LoginFormProps = {
  onLogin?: () => void

  // If for some reason, you have conflicts with the IDs nodes generated by
  // LoginForm, you can add a id prefix.
  // This can also be useful if you need to embed more than one AccountCreationForm
  // in the same page.
  idPrefix?: string

  // Render labels before inputs in the form (default true)
  labelsFirst?: boolean

  // Provide a special input component for the TOTP token input and Recovery Code
  // input
  TotpInputComponent?: InputComponentType
  RecoveryCodeInputComponent?: InputComponentType
}

const SocialLoginButton: React.FC<{
  onClick: (e: MouseEvent) => void,
  buttonClasses: string,
  children: ReactNode
}> = ({onClick, buttonClasses, children}) => (
  <div className="d-flex justify-content-center my-2">
    <button className={classNames("btn btn-block btn-outline-primary d-flex align-items-center justify-content-between", buttonClasses)}
      onClick={onClick}>
      {children}
    </button>
  </div>
)

type ChildWindow = {
  open: (url: string) => void
  close: () => void
}

const useChildWindow = (name: string, callback: (msg: any) => void): ChildWindow => {

  const [prevUrl, setPrevUrl] = useState<string | null>(null)
  const [childWindow, setChildWindow] = useState<Window | null>(null)
  const [curCallback, setCurCallback] = useState<((event: any) => void) | null>(null)

  const close = () => {
    if (childWindow != null) {
      childWindow.close()
      setChildWindow(null)
      setPrevUrl(null)
    }
  }

  const open = (url: string) => {
    const top = window.screenY + (window.screen.height - 700) / 2
    const left = window.screenX + (window.screen.width - 600) / 2

    const features =
     `toolbar=no, menubar=no, width=600, height=700, top=${top}, left=${left}`

    let newWindow: Window | null = null
    if (childWindow === null || childWindow.closed) {
      // if the pointer to the window object in memory does not exist
      // or if such pointer exists but the window was closed
      newWindow = window.open(url, name, features)
    } else if (prevUrl !== url) {
      // if the resource to load is different,
      // then we load it in the already opened secondary window and then
      // we bring such window back on top/in front of its parent window. */
      newWindow = window.open(url, name, features)
      newWindow?.focus()
    } else {
      // else the window reference must exist and the window
      // is not closed; therefore, we can bring it back on top of any other
      // window with the focus() method. There would be no need to re-create
      // the window or to reload the referenced resource. */
      childWindow.focus()
    }

    if (newWindow != null) {
      if (curCallback != null) {
        window.removeEventListener('message', curCallback, false)
      }

      const callbackWrapper = (event: any) => {
        // We get null events sometimes, i have no idea why
        if (event == null) { return }
        if (event.origin !== window.origin) {
          console.error(`ignored cross-origin message from ${event.origin}`)
          return
        }
        // event.source is documented here at
        // https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent
        // It matches the WindowProxy we got from window.open, whereas
        // event.srcElement matches the current window, and isn't what we
        // want.
        // TODO: this apparently won't work on IE11. find a workaround
        if (event.source !== newWindow) {
          return
        }
        callback(event.data)
      }

      window.addEventListener('message', callbackWrapper, false)

      setChildWindow(newWindow)
      setPrevUrl(url)
      setCurCallback(callbackWrapper)
    }
  }

  return { open, close }
}

const makeNonce = () => {
  // @ts-ignore
  const crypto = window.crypto || window.msCrypto

  if (crypto == null) {
    throw new Error("Error: No crypto implementation available")
  }

  const arr = new Uint8Array(16)
  crypto.getRandomValues(arr)

  const ret = []
  for (let i = 0; i < arr.length; i++) {
    ret.push(arr[i].toString(16))
  }
  return ret.join('')
}

const makeLoginFn = (childWindow: ChildWindow, appId: string, url: string) => (
  (e: MouseEvent) => {
    e.preventDefault()
    const nonce = makeNonce()
    window.localStorage.umAuthNonce = nonce
    const childUrl = `${url}?appId=${appId}&nonce=${nonce}`

    childWindow.open(childUrl)
  }
)

const SocialButtons: React.FC<{popupWindow: ChildWindow, className?: string}> = ({popupWindow, className}) => {

  const appId = useAppId()

  const {
    fbLoginEnabled,
    fbLoginUrl,
    googleLoginEnabled,
    googleLoginUrl,
    githubLoginEnabled,
    githubLoginUrl,
  } = useAppConfig()

  const loginWithFacebook = makeLoginFn(popupWindow, appId, fbLoginUrl)
  const loginWithGoogle = makeLoginFn(popupWindow, appId, googleLoginUrl)
  const loginWithGithub = makeLoginFn(popupWindow, appId, githubLoginUrl)

  if (!fbLoginEnabled && !googleLoginEnabled && !githubLoginEnabled) {
    return null
  } else {
    // poor man's name mangling... We just need to avoid
    // conflicting with apps that use this library.
    const nonce = '3kdic7az9'
    const buttonClass = (provider: string) => {
      return `${provider}-login-btn-${nonce}`
    }
    return <div className={classNames(className)}>
      <style>{`
          .facebook-login-btn-${nonce} {
            color: white !important;
            background-color: #4267b2 !important;
            border-color: #4267b2 !important;
          }
          .facebook-login-btn-${nonce}:hover {
            color: #4267b2 !important;
            background-color: white !important;
          }

          .google-login-btn-${nonce} {
            color: white !important;
            background-color: #ea4335 !important;
            border-color: #ea4335 !important;
          }
          .google-login-btn-${nonce}:hover {
            color: #ea4335 !important;
            background-color: white !important;
          }

          .github-login-btn-${nonce} {
            color: white !important;
            background-color: rgb(21, 20, 19) !important;
            border-color: rgb(21, 20, 19) !important;
          }
          .github-login-btn-${nonce}:hover {
            color: rgb(21, 20, 19) !important;
            background-color: white !important;
          }
      `}</style>
      { githubLoginEnabled &&
        <SocialLoginButton onClick={loginWithGithub} buttonClasses={buttonClass('github')}>
          <GithubLogo size="2em"/>
          <div className="flex-grow-1 font-weight-bold">Login with GitHub</div>
        </SocialLoginButton>
      }
      { fbLoginEnabled &&
        <SocialLoginButton onClick={loginWithFacebook} buttonClasses={buttonClass('facebook')}>
          <FbLogo size="2em"/>
          <div className="flex-grow-1 font-weight-bold">Login with Facebook</div>
        </SocialLoginButton>
      }
      { googleLoginEnabled &&
        <SocialLoginButton onClick={loginWithGoogle} buttonClasses={buttonClass('google')}>
          <GoogleLogo size="2em"/>
          <div className="flex-grow-1 font-weight-bold">Login with Google</div>
        </SocialLoginButton>
      }
    </div>
  }
}

// Return a child window that, when opened, can initiate the oauth redirect,
// and sends the oauthToken back to the opener once it is received.
const useGetOauthToken = (onToken: (token: string) => void) => {

  const popupWindow = usePopupWindow({onToken})

  // oauthToken becomes non-null in the child window after the oauth redirect
  // completes
  const oauthToken = useOauthToken()

  // Send the token back to window.opener once we have it. This will never
  // execute in the parent window.
  useEffect(() => {
    if (oauthToken && window.opener != null) {
      window.opener.postMessage({ oauthToken })
      window.close()
    }
  }, [oauthToken])

  return { popupWindow }
}

type OauthLoginProps = LoginFormProps & { children: ReactNode }

const OauthCreateAccount: React.FC<OauthLoginProps> = ({
  onLogin, children
}) => {

  const [submit, { loading, error }] = useLogin({
    onCompleted: () => { onLogin?.() }
  })
  const [oauthToken, setOauthToken] = useState<string | undefined>()
  const { popupWindow } = useGetOauthToken(setOauthToken)

  useEffect(() => {
    if (oauthToken) {
      submit({
        credential: { oauthToken },
        stayLoggedIn: false,
      })
    }
  }, [oauthToken])

  if (oauthToken == null) {
    return <>
      <SocialButtons popupWindow={popupWindow} className="my-3"/>
      {children}
    </>
  } else {
    return <>
      <ErrorMessage error={error} />
      { loading && <div className="alert alert-info">
        Please wait while we process your login...
      </div> }
    </>
  }
}

const usePopupWindow = ({onToken}: { onToken: (token: string) => void }) => (
  useChildWindow('social-login-popup',
    async (msg: any) => {
      if (msg.oauthToken) {
        onToken(msg.oauthToken)
      }
    }
  )
)

const loginInitialValues = {
  email: '',
  password: '',
  stayLoggedIn: false
}

type LoginSubmitArgs = typeof loginInitialValues

const validateLogin = (values: FormikValues) => {
  const errors: FormikErrors<typeof loginInitialValues> = {}

  if (!values.password) {
    errors.password = 'Required'
  }

  if (!values.email) {
    errors.email = 'Required'
  } else if (!/.+@.+/.test(values.email)) {
    errors.email = 'Please enter an email address'
  }

  return errors
}

type LoginMode = 'login' | 'forgotpw' | 'totp'

const PostRecoveryCode: React.FC<{dismiss: () => void }> = ({dismiss}) => {

  const reauthToken = useReauthToken()
  const { count, loading: countLoading } = useGetRecoveryCodeCount()
  const [submit, { called, loading, error }] = useCsrfMutation(useClearTotpMutation)

  const reset2FA = (e: MouseEvent) => {
    e.preventDefault()
    submit({ variables: { reauthToken } })
  }

  const onClickDismiss = (e: MouseEvent) => {
    e.preventDefault()
    dismiss()
  }

  if (called && !loading && !error) {
    return <div>
      <div className="alert alert-info">
        You have disabled 2FA. Please consider re-enabling it as soon as possible.
      </div>
      <button className="btn btn-outline-primary btn-block" onClick={onClickDismiss}>
        Okay
      </button>
    </div>
  }

  const buttonClasses = "btn btn-outline-primary btn-block font-weight-bolder"

  return <div>
    <div className="alert alert-secondary">
      You have logged in via a recovery code.
      The code you just used will no longer work.
      { !countLoading && <>You have {count} recovery codes remaining.</> }
    </div>
    <div className="my-3 d-flex justify-content-center">
      Do you need to reset your 2FA codes?
    </div>
    <ErrorMessage error={error} />
    <button
      className={classNames(buttonClasses, "mb-3", loading && 'disabled')}
      onClick={reset2FA}
    >
      { loading
        ? 'Please wait...'
        : 'I lost my phone and need to turn 2FA off for now.' }
    </button>
    <button
      className={classNames(buttonClasses, called && 'disabled')}
      onClick={dismiss}
    >
      I still have my phone, but not with me. Leave 2FA on.
    </button>
  </div>
}

const TOTPFlow: React.FC<{
  idPrefix?: string,
  error?: ApolloError,
  loading: boolean,
  submit: (totpCode: string) => void,
  totpRequired: boolean,
  TotpInputComponent?: InputComponentType,
  RecoveryCodeInputComponent?: InputComponentType
}> = ({
  idPrefix, error, loading, submit, totpRequired, TotpInputComponent, RecoveryCodeInputComponent
}) => (
  <div className="d-flex flex-column align-items-center">
    { // Don't display the error message that says we need a code...
      !totpRequired && <ErrorMessage error={error} /> }
    <MFAForm submit={submit} idPrefix={idPrefix}
       TotpInputComponent={TotpInputComponent}
       RecoveryCodeInputComponent={RecoveryCodeInputComponent}
    />
    { loading && <div>Please wait...</div> }
  </div>
)

export const LoginForm: React.FC<LoginFormProps> = ({
  onLogin,
  idPrefix,
  labelsFirst: labelsFirstArg,
  TotpInputComponent,
  RecoveryCodeInputComponent
}) => {

  const labelsFirst = labelsFirstArg ?? true

  // State
  const [mode, setMode] = useState<LoginMode>('login')
  const [submittedData, setSubmittedData] =
    useState<LoginMutationVariables | undefined>(undefined)
  const [oauthToken, setOauthToken] = useState<string | undefined>()
  const [successViaRecoveryCodeDismissed, setSuccessViaRecoveryCodeDismissed] =
    useState<boolean>(false)
  const [stayLoggedIn, setStayLoggedIn] = useState<boolean>(false)

  // are we logged in?
  const { id, loading: tokenLoading } = useToken()

  // the login mutation
  const [submit, { loading, error, called, success, data }] = useLogin()

  const submitWrapper = (variables: LoginMutationVariables) => {
    submit(variables)
    setSubmittedData(variables)
  }

  const { popupWindow } = useGetOauthToken(setOauthToken)

  // derived state...
  const totpRequired = Boolean(error?.graphQLErrors.find(
    e => e.extensions?.exception?.code === 'TOTP_REQUIRED'
  ))

  const totpCode = submittedData?.credential.totpCode
  const successViaRecoveryCode = called && success
    && totpCode && /^[-0-9A-Z]{14}$/.test(totpCode)

  // Do the oauth login as soon as we have a token.
  useEffect(() => {
    if (oauthToken) {
      submitWrapper({
        stayLoggedIn,
        ...submittedData,
        credential: { oauthToken }
      })
    }
  }, [oauthToken])

  useEffect(() => {
    // We need to wait until the credential context is reporting that we are logged in,
    // (in addition to waiting for useLogin() mutation to finish). Otherwise there's a window
    // during which other components might think we aren't logged in, even though we are
    // about to be.
    if (called && success && id && !tokenLoading && onLogin &&
        (!successViaRecoveryCode || successViaRecoveryCodeDismissed)) {
      onLogin()
    }
  }, [called, success, id, tokenLoading, onLogin,
      successViaRecoveryCode, successViaRecoveryCodeDismissed])


  useEffect(() => {
    if (mode !== 'totp' && totpRequired) {
      setMode('totp')
    }
  }, [totpRequired, mode])

  if (successViaRecoveryCode) {
    const dismiss = () => {
      setSuccessViaRecoveryCodeDismissed(true)
    }
    return <ReauthContext.Provider value={data?.login?.user.reauthToken ?? ''}>
      <PostRecoveryCode dismiss={dismiss}/>
    </ReauthContext.Provider>
  }

  if (mode === 'totp') {
    const submitCode = (totpCode: string) => {
      if (oauthToken) {
        submitWrapper({
          credential: { oauthToken, totpCode },
          stayLoggedIn
        })
      } else if (submittedData) {
        const variables = {
          ...submittedData,
          credential: {
            ...submittedData.credential,
            totpCode
          }
        }
        submitWrapper(variables)
      } else {
        throw new Error("no oauthToken or saved login data")
      }
    }
    return <TOTPFlow
      submit={submitCode}
      idPrefix={idPrefix}
      error={error}
      loading={loading}
      TotpInputComponent={TotpInputComponent}
      RecoveryCodeInputComponent={RecoveryCodeInputComponent}
      totpRequired={totpRequired}
    />
  } else if (mode === 'forgotpw') {
    return <div>
      <div>
        Enter your email to get a password reset link.
      </div>
      <RequestPasswordResetForm idPrefix={idPrefix} labelsFirst={labelsFirst}
        onCancel={() => { setMode('login')}} />
    </div>
  } else if (mode === 'login') {

    const onSubmit = (values: LoginSubmitArgs) => {
      const { password, email } = values
      const variables = {
        credential: { password: { password, email } },
        stayLoggedIn
      }
      submitWrapper(variables)
    }

    return <>
      <SocialButtons popupWindow={popupWindow} className="my-3"/>
      <Formik initialValues={loginInitialValues}
              onSubmit={onSubmit}
              validate={validateLogin}>
        {(props) => {
          const {
            onChange: onStayLoggedInChange,
            ...stayLoggedInRest
          } = props.getFieldProps('stayLoggedIn')
          return <Form>
            <div className="form-label-group mb-2">
              <InputLabel flip={labelsFirst}>
                <Field type="email" name="email" className="form-control"
                       id={getId(idPrefix, "login-email")}
                       placeholder="Email address" required autoFocus />
                <label htmlFor={getId(idPrefix, "login-email")}>Email address</label>
              </InputLabel>
            </div>

            <div className="form-label-group mb-2">
              <InputLabel flip={labelsFirst}>
                <Field type="password" name="password" className="form-control"
                       id={getId(idPrefix, "login-password")}
                       placeholder="Password" required />
                <label htmlFor={getId(idPrefix, "login-password")}>Password</label>
              </InputLabel>
            </div>

            <div className="custom-control custom-checkbox mb-2">
              <input type="checkbox" className="custom-control-input"
                     id={getId(idPrefix, "login-stay-logged-in")}
                     onChange={(e) => {
                       onStayLoggedInChange(e)
                       // We also need to store this outside the form, so that
                       // oauth logins can use it.
                       setStayLoggedIn(e.target.checked)
                     }}
                     {...stayLoggedInRest}
              />
              <label className="custom-control-label" htmlFor={getId(idPrefix, "login-stay-logged-in")}>
                Remember me
              </label>
            </div>

            <div className="mb-3 justify-content-between d-flex">
              <button id="login-button" className="btn btn-primary" type="submit">Sign in</button>
              <button id="forgot-pw-button" className="btn btn-outline-primary" type="button"
                      onClick={(e) => { e.preventDefault(); setMode('forgotpw'); }}>
                Forgot Password?
              </button>
            </div>
            <ErrorMessage error={error} />
          </Form>
        }}
      </Formik>
    </>
  }
  throw new Error("unreachable")
}

// User creation error messages are likely to occur in normal situations,
// so they get a bit more attention than ErrorMessage can give.
const UserCreateError: React.FC<{error?: ApolloError}> = ({error}) => {
  if (!error) { return null }

  const formatMsg = (e: GraphQLError) => {
    if (e.extensions == null) {
      return null
    }
    const { exception } = e.extensions
    if (exception) {
      switch (exception.code) {
        case 'EMAIL_EXISTS':
          return <>
            An account with the email address {e.extensions.email} already exists.
          </>
      }
    }

    return e.message
  }

  return <>
    {error.graphQLErrors.map((e, i) => (
      <div className="alert alert-danger" role="alert" key={i}>
        {formatMsg(e) || 'uknown error'}
      </div>
    ))}
  </>
}

type AccountCreationProps = {
  loginAfterCreation?: boolean
  onLogin?: () => void

  // If for some reason, you have conflicts with the IDs nodes generated by
  // AccountCreationForm, you can add a id prefix.
  // This can also be useful if you need to embed more than one AccountCreationForm
  // in the same page.
  idPrefix?: string

  // Render labels before inputs in the form (default true)
  labelsFirst?: boolean

  // Display the PasswordScore widget.
  showPasswordScore?: boolean
}

export const AccountCreationForm: React.FC<AccountCreationProps> = ({
  loginAfterCreation: loginAfterCreationArg = true,
  onLogin,
  idPrefix,
  labelsFirst: labelsFirstArg = true,
  showPasswordScore = true
}) => {

  const labelsFirst = labelsFirstArg
  const loginAfterCreation = loginAfterCreationArg

  const { id } = useToken()
  const [submit, { error, success }] = useCreateAccount()

  useEffect(() => {
    if (success && id && onLogin) {
      onLogin()
    }
  })

  const onSubmit = (variables: CreateAccountMutationVariables) => {
    submit(variables)
  }

  return <OauthCreateAccount onLogin={onLogin}>
    <Formik initialValues={loginInitialValues}
            onSubmit={onSubmit}
            validate={validateLogin}>
    {(props) => (
      <Form autoComplete="off">
        <div className="form-label-group mb-2">
          <InputLabel flip={labelsFirst}>
            <Field type="email" name="email" className="form-control"
                   id={getId(idPrefix, "account-creation-email")}
                   placeholder="Email address" required autoFocus />
            <label htmlFor={getId(idPrefix, "account-creation-email")}>Email address</label>
          </InputLabel>
        </div>

        <div className="form-label-group mb-2">
          <InputLabel flip={labelsFirst}>
            <Field type="password" name="password" className="form-control"
                   id={getId(idPrefix, "account-creation-password")}
                   placeholder="Password" required />
            <label htmlFor={getId(idPrefix, "account-creation-password")}>Password</label>
          </InputLabel>
        </div>

        { loginAfterCreation &&
        <div className="custom-control custom-checkbox mb-2">
          <Field type="checkbox" className="custom-control-input" name="stayLoggedIn"
                 id={getId(idPrefix, "account-creation-stay-logged-in")} />
          <label className="custom-control-label" htmlFor={getId(idPrefix, "account-creation-stay-logged-in")}>
            Remember me
          </label>
        </div> }

        { showPasswordScore &&
          <PasswordScore password={props.values.password} username={props.values.email} />
        }

        <div className="mb-3">
          <button className="btn btn-primary" type="submit">Create Account</button>
        </div>
      </Form>
    )}
    </Formik>
    <UserCreateError error={error} />
  </OauthCreateAccount>
}

export const LogoutButton: React.FC<{}> = () => {

  const [submit, { error }] = useLogout()

  const onClick = (e: MouseEvent) => {
    e.preventDefault()
    submit()
  }

  return <>
    <button className="btn btn-outline-primary" type="button" onClick={onClick}>Logout</button>
    <ErrorMessage error={error} />
  </>
}
